{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MacroSim Documentation MacroSim is a python library aimed at creating symbloic models of economic variables thgough PySR's PySRRegressor . It utilizes a FRED series accessor and a cunstomizable equation search engine to find an accurate smybolic representation of the selected variavle using the features retrieved from FRED series. MacroSim contains a simulation engine that has the capability to extrapolate the given data points using fully symbolic, per-variable growth rate equations. MacroSim's main focus is not on producing the most accurate output, but to ensure explorability of outputs for research purposes. Both the symbolic regression results and the fitted growth equations prioritize interpretability. Although kinks are often produced in the output extrapolation process, the equations themselves are configured to be differenciable in most cases. Installation MacroSim can be intalled throuh pip ; and the builds are available in the github repo if you prefer to install it manually. The pip command required to retireve MacroSim is: python -m pip install macrosim","title":"Home"},{"location":"#macrosim-documentation","text":"MacroSim is a python library aimed at creating symbloic models of economic variables thgough PySR's PySRRegressor . It utilizes a FRED series accessor and a cunstomizable equation search engine to find an accurate smybolic representation of the selected variavle using the features retrieved from FRED series. MacroSim contains a simulation engine that has the capability to extrapolate the given data points using fully symbolic, per-variable growth rate equations. MacroSim's main focus is not on producing the most accurate output, but to ensure explorability of outputs for research purposes. Both the symbolic regression results and the fitted growth equations prioritize interpretability. Although kinks are often produced in the output extrapolation process, the equations themselves are configured to be differenciable in most cases.","title":"MacroSim Documentation"},{"location":"#installation","text":"MacroSim can be intalled throuh pip ; and the builds are available in the github repo if you prefer to install it manually. The pip command required to retireve MacroSim is: python -m pip install macrosim","title":"Installation"},{"location":"class_docs/EqSearch/","text":"EqSearch EqSearch is responsible with applying symbolic regression to derive target equations for simulation. It utilizes pysr's PySRRegressor model, which is written and pre-compiled in julia. As an important note, pysr is currently in development and UnicodeDecodeError s are common during equation searches. (only tested in ipython environments) Although raised, these byte decode errors do not interrupt the runtime and better ipython support will likely be implemented at some point. To generalize the output expressions, an aggressive outlier elimination process is applied in EqSearch . This increases the chances of getting differentiable and interpretable outputs. n-neighbor based outlier detection is implemented with sklearn 's LocalOutlierFactor model and after the LOF based outlier elimination, the remaining data is further distilled through the use of a RandomForestRegressor . Following this procedure, PySRRegressor is utilized to conduct an iterative search for the best fitting symbolic expression within the user-defined constraints. Example Usage from macrosim import EqSearch from pandas import DataFrame, Series from sympy import sin x: DataFrame = ... y: Series | DataFrame = ... eqsr = EqSearch( X=x, # features y=y, # label random_state=0, model_selection='best' ) eqsr.distil_split(grid_search=False) # Model distillation (required step) eqsr.search( extra_unary_ops={ 'sin': { 'julia': 'sin', 'sympy': lambda x: sin(x) } }, constraints={'sin': 2, '^': (-1, 1)} # Complexity limit of terms in binary and unary operations ) eq = eqsr.eq Methods EqSearch.distil_split Applies outlier handling and model distillation. Params: - test_size: float : test size used for the data split of RandomForestRegressor . - grid_search: bool : Conduct cross-validated grid search for RandomForestRegressor tuning if True. - gs_params: dict[str, list[Any]] : Param grid to use if grid_search=True . Returns: - None EqSearch.search Uses PySRRegressor to conduct a symbolic expression search. Calling search before distil_split will raise an AssertionError . Records the resulting equation as a sympy expression to self.eq . Params: - binary_ops: tuple[str] : tuple of binary operators (as strings) allowed in the final expression. Defaults to use all binary operators available. unary_ops: tuple[str] : tuple of unary operators allowed in the final expression. Defaults to ('exp', 'log', 'sqrt') . extra_unary_ops: dict[str, dict[str, Any]] : dict of unary ops that are not built-in to python, sympy, or julia. Every search will include the extra unary: {'inv': {julia: 'inv(x)=1/x', 'sympy': lambda x: 1/x} . For each operator, a julia and sympy applicable definition is necessary. julia implementations are passed as strings in julia syntax, to be parsed on the PySRRegressor side. custom_loss: str : elementwise loss function to use, either written in julia syntax or a string literal for predefined loss functions, available in PySR documentation . Defaults to 'L2DistLoss()'. (sum of square difference, similar to MSE) constraints: dict[str, Union[int, tuple[int, int]] : constraints to expression complexity of binary and unary operations. Complexity, in this case, refers to the amount of operations required to reduce an input to its simplest form. For example, 1+1 can be reduced to it's simplest form in one addition, making it's overall complexity equal to 1 while a*1+1 would require at least 2 operations, so it has a complexity of 2. (assuming a is a scalar) For unary operations, an integer is passed to define how complex of an input can be used. For example, a complexity of 1 would only allow a single variable or constant. With a complexity of 1, the sin operator would only be used as sin(x) while a complexity of 2 would for example allow sin(x+C) . Binary operators function similarly, but their constraints are defined as a tuple of integers, for the inputs x , and y of the operation. For example, a constraint of (1, 1) on the ^ operator would only allow expressions of type x^y while a constraint of (2, 1) would allow (x+1)^y . Returns: - None (Results saved to self.eq )","title":"EqSearch"},{"location":"class_docs/EqSearch/#eqsearch","text":"EqSearch is responsible with applying symbolic regression to derive target equations for simulation. It utilizes pysr's PySRRegressor model, which is written and pre-compiled in julia. As an important note, pysr is currently in development and UnicodeDecodeError s are common during equation searches. (only tested in ipython environments) Although raised, these byte decode errors do not interrupt the runtime and better ipython support will likely be implemented at some point. To generalize the output expressions, an aggressive outlier elimination process is applied in EqSearch . This increases the chances of getting differentiable and interpretable outputs. n-neighbor based outlier detection is implemented with sklearn 's LocalOutlierFactor model and after the LOF based outlier elimination, the remaining data is further distilled through the use of a RandomForestRegressor . Following this procedure, PySRRegressor is utilized to conduct an iterative search for the best fitting symbolic expression within the user-defined constraints.","title":"EqSearch"},{"location":"class_docs/EqSearch/#example-usage","text":"from macrosim import EqSearch from pandas import DataFrame, Series from sympy import sin x: DataFrame = ... y: Series | DataFrame = ... eqsr = EqSearch( X=x, # features y=y, # label random_state=0, model_selection='best' ) eqsr.distil_split(grid_search=False) # Model distillation (required step) eqsr.search( extra_unary_ops={ 'sin': { 'julia': 'sin', 'sympy': lambda x: sin(x) } }, constraints={'sin': 2, '^': (-1, 1)} # Complexity limit of terms in binary and unary operations ) eq = eqsr.eq","title":"Example Usage"},{"location":"class_docs/EqSearch/#methods","text":"","title":"Methods"},{"location":"class_docs/EqSearch/#eqsearchdistil_split","text":"Applies outlier handling and model distillation. Params: - test_size: float : test size used for the data split of RandomForestRegressor . - grid_search: bool : Conduct cross-validated grid search for RandomForestRegressor tuning if True. - gs_params: dict[str, list[Any]] : Param grid to use if grid_search=True . Returns: - None","title":"EqSearch.distil_split"},{"location":"class_docs/EqSearch/#eqsearchsearch","text":"Uses PySRRegressor to conduct a symbolic expression search. Calling search before distil_split will raise an AssertionError . Records the resulting equation as a sympy expression to self.eq . Params: - binary_ops: tuple[str] : tuple of binary operators (as strings) allowed in the final expression. Defaults to use all binary operators available. unary_ops: tuple[str] : tuple of unary operators allowed in the final expression. Defaults to ('exp', 'log', 'sqrt') . extra_unary_ops: dict[str, dict[str, Any]] : dict of unary ops that are not built-in to python, sympy, or julia. Every search will include the extra unary: {'inv': {julia: 'inv(x)=1/x', 'sympy': lambda x: 1/x} . For each operator, a julia and sympy applicable definition is necessary. julia implementations are passed as strings in julia syntax, to be parsed on the PySRRegressor side. custom_loss: str : elementwise loss function to use, either written in julia syntax or a string literal for predefined loss functions, available in PySR documentation . Defaults to 'L2DistLoss()'. (sum of square difference, similar to MSE) constraints: dict[str, Union[int, tuple[int, int]] : constraints to expression complexity of binary and unary operations. Complexity, in this case, refers to the amount of operations required to reduce an input to its simplest form. For example, 1+1 can be reduced to it's simplest form in one addition, making it's overall complexity equal to 1 while a*1+1 would require at least 2 operations, so it has a complexity of 2. (assuming a is a scalar) For unary operations, an integer is passed to define how complex of an input can be used. For example, a complexity of 1 would only allow a single variable or constant. With a complexity of 1, the sin operator would only be used as sin(x) while a complexity of 2 would for example allow sin(x+C) . Binary operators function similarly, but their constraints are defined as a tuple of integers, for the inputs x , and y of the operation. For example, a constraint of (1, 1) on the ^ operator would only allow expressions of type x^y while a constraint of (2, 1) would allow (x+1)^y . Returns: - None (Results saved to self.eq )","title":"EqSearch.search"},{"location":"class_docs/GrowthPatternDetector/","text":"GrowthPatternDetector Docs will be written when the first beta release of SimEngine is out.","title":"GrowthPatternDetector"},{"location":"class_docs/GrowthPatternDetector/#growthpatterndetector","text":"Docs will be written when the first beta release of SimEngine is out.","title":"GrowthPatternDetector"},{"location":"class_docs/SeriesAccessor/","text":"SeriesAccessor SeriesAccessor is a wrapper class built around the fredapi library to provide additional utilities that come in handy when working with time series of varying frequencies at the same time. Retrieving data through this class is not a necessity and EqSearch will essentially work with any arbitrary dataset that's suitable to regression. Also, note that you'll need a free API key to access FRED series, you can follow this article to get one. Example Usage from macrosim import SeriesAccessor import datetime as dt fred = SeriesAccessor( key_path='./key.env', # The class expects an .env file, the is loaded through environment variables key_name='fred_key' # Name of the variable holding the API key in the .env file. ) start = dt.datetime.fromisoformat(\"2000-01-01\") end = dt.datetime.fromisoformat(\"2024-01-01\") df = fred.get_series(series_ids=['CPIAUCSL', 'A264RX1A020NBEA', 'PSAVERT', 'M2REAL', 'GDPC1'], # FRED IDs of the series date_range=(start, end), reindex_freq='QS', # Chosen time series frequency to reindex all data (defaults to max frequency available in the data series_alias=['CPI', 'CAPINV','SRATE', 'M_2','RGDP']) # Col names to use in the output (this will change how variables are represented in equations) df = fred.fill( df, [None, 'ffill', None, None, None] # Provide None, a built-in fill method, or a unary lambda function per column to fill the NaN values produced at reindexing ) Methods SeriesAccessor includes two user-facing methods and it's only functionality is to retrieve and format series from FRED. SeriesAccessor.get_series Retrieves the specified FRED series and applies the specified formatting. Params: - series_ids: Sequence[str] : List of FRED series IDs to retireve - date_range: tuple(dt.datetime.date, dt.datetime.date) : Date interval to retrieve data for. - reindex_freq: str : String literal of the observation frequency to reformat the series - series_alias: Sequence[str] : List of aliases to use as column names in the outputted dataframe. EqSearch will use these as the variable names when outputting symbolic equations. Returns: - pd.DataFrame : Concatenated and re-indexed dataframe of the series specified SeriesAccessor.fill Fills the given data with specified fill methods. Params: - df: pd.DataFrame : DataFrame object to apply the fill methods - fill_methods : a list of fill methods for each column in the dataframe. The default behavior is to fill the list with None s until the amount of methods match the mount of columns in the data. The methods can be a unary lambda function, or one of the built-in fill methods passed as a string. The available methods are: - ffill : forward-fill, behaves exactly same as pd.Series.ffill . - bfill : backward-fill, behaves exactly same as pd.Series.bfill . - divide : Divide the last known value equally to \\(n\\) NaN values encountered before the next available row. For example, this can be used to evenly split yearly data to a monthly or quarterly observation frequency. - mean : Use the mean to fill NaNs. - median : Use the median to fill NaNs. - IQR_mean : Use the mean calculated from data within the IQR to fill NaNs.","title":"SeriesAccessor"},{"location":"class_docs/SeriesAccessor/#seriesaccessor","text":"SeriesAccessor is a wrapper class built around the fredapi library to provide additional utilities that come in handy when working with time series of varying frequencies at the same time. Retrieving data through this class is not a necessity and EqSearch will essentially work with any arbitrary dataset that's suitable to regression. Also, note that you'll need a free API key to access FRED series, you can follow this article to get one.","title":"SeriesAccessor"},{"location":"class_docs/SeriesAccessor/#example-usage","text":"from macrosim import SeriesAccessor import datetime as dt fred = SeriesAccessor( key_path='./key.env', # The class expects an .env file, the is loaded through environment variables key_name='fred_key' # Name of the variable holding the API key in the .env file. ) start = dt.datetime.fromisoformat(\"2000-01-01\") end = dt.datetime.fromisoformat(\"2024-01-01\") df = fred.get_series(series_ids=['CPIAUCSL', 'A264RX1A020NBEA', 'PSAVERT', 'M2REAL', 'GDPC1'], # FRED IDs of the series date_range=(start, end), reindex_freq='QS', # Chosen time series frequency to reindex all data (defaults to max frequency available in the data series_alias=['CPI', 'CAPINV','SRATE', 'M_2','RGDP']) # Col names to use in the output (this will change how variables are represented in equations) df = fred.fill( df, [None, 'ffill', None, None, None] # Provide None, a built-in fill method, or a unary lambda function per column to fill the NaN values produced at reindexing )","title":"Example Usage"},{"location":"class_docs/SeriesAccessor/#methods","text":"SeriesAccessor includes two user-facing methods and it's only functionality is to retrieve and format series from FRED.","title":"Methods"},{"location":"class_docs/SeriesAccessor/#seriesaccessorget_series","text":"Retrieves the specified FRED series and applies the specified formatting. Params: - series_ids: Sequence[str] : List of FRED series IDs to retireve - date_range: tuple(dt.datetime.date, dt.datetime.date) : Date interval to retrieve data for. - reindex_freq: str : String literal of the observation frequency to reformat the series - series_alias: Sequence[str] : List of aliases to use as column names in the outputted dataframe. EqSearch will use these as the variable names when outputting symbolic equations. Returns: - pd.DataFrame : Concatenated and re-indexed dataframe of the series specified","title":"SeriesAccessor.get_series"},{"location":"class_docs/SeriesAccessor/#seriesaccessorfill","text":"Fills the given data with specified fill methods. Params: - df: pd.DataFrame : DataFrame object to apply the fill methods - fill_methods : a list of fill methods for each column in the dataframe. The default behavior is to fill the list with None s until the amount of methods match the mount of columns in the data. The methods can be a unary lambda function, or one of the built-in fill methods passed as a string. The available methods are: - ffill : forward-fill, behaves exactly same as pd.Series.ffill . - bfill : backward-fill, behaves exactly same as pd.Series.bfill . - divide : Divide the last known value equally to \\(n\\) NaN values encountered before the next available row. For example, this can be used to evenly split yearly data to a monthly or quarterly observation frequency. - mean : Use the mean to fill NaNs. - median : Use the median to fill NaNs. - IQR_mean : Use the mean calculated from data within the IQR to fill NaNs.","title":"SeriesAccessor.fill"},{"location":"class_docs/SimEngine/","text":"SimEngine Docs will be written when the first beta release of SimEngine is out.","title":"SimEngine"},{"location":"class_docs/SimEngine/#simengine","text":"Docs will be written when the first beta release of SimEngine is out.","title":"SimEngine"}]}